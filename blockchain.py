# -*- coding: utf-8 -*-
"""Blockchain.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ZM0ORvH137N_fkoUOID3oku_521qqblJ
"""

import hashlib
import time

class Transaction:
    def __init__(self, sender, recipient, amount):
        self.sender = sender
        self.recipient = recipient
        self.amount = amount

    def __repr__(self):
        return f"Transaction({self.sender}, {self.recipient}, {self.amount})"

class Block:
    def __init__(self, index, previous_hash, timestamp, transactions, nonce, hash):
        self.index = index
        self.previous_hash = previous_hash
        self.timestamp = timestamp
        self.transactions = transactions
        self.nonce = nonce
        self.hash = hash

    def __repr__(self):
        return f"Block(Index: {self.index}, Hash: {self.hash}, Transactions: {self.transactions})"

def calculate_hash(index, previous_hash, timestamp, transactions, nonce):
    value = str(index) + str(previous_hash) + str(timestamp) + str(transactions) + str(nonce)
    return hashlib.sha256(value.encode()).hexdigest()

def create_genesis_block():
    genesis_transactions = [Transaction("Genesis", "Genesis", 0)]
    return Block(0, "0", int(time.time()), genesis_transactions, 0, calculate_hash(0, "0", int(time.time()), genesis_transactions, 0))

class Blockchain:
    def __init__(self, difficulty=2):
        self.chain = [create_genesis_block()]
        self.pending_transactions = []
        self.difficulty = difficulty

    def get_last_block(self):
        return self.chain[-1]

    def add_transaction(self, sender, recipient, amount):
        transaction = Transaction(sender, recipient, amount)
        self.pending_transactions.append(transaction)

    def mine_pending_transactions(self):
        previous_block = self.get_last_block()
        new_block = self.create_new_block(previous_block, self.pending_transactions, self.difficulty)
        self.chain.append(new_block)
        self.pending_transactions = []
        return new_block

    def is_chain_valid(self):
        for i in range(1, len(self.chain)):
            current_block = self.chain[i]
            previous_block = self.chain[i - 1]


            if current_block.hash != calculate_hash(current_block.index, current_block.previous_hash, current_block.timestamp, current_block.transactions, current_block.nonce):
                return False

            if current_block.previous_hash != previous_block.hash:
                return False

            if not current_block.hash.startswith('0' * self.difficulty):
                return False

        return True

    def create_new_block(self, previous_block, transactions, difficulty):
        index = previous_block.index + 1
        timestamp = int(time.time())
        nonce = 0
        hash = calculate_hash(index, previous_block.hash, timestamp, transactions, nonce)
        while not hash.startswith('0' * difficulty):
            nonce += 1
            hash = calculate_hash(index, previous_block.hash, timestamp, transactions, nonce)

        return Block(index, previous_block.hash, timestamp, transactions, nonce, hash)

if __name__ == "__main__":
    blockchain = Blockchain()

    blockchain.add_transaction("Alice", "Bob", 50)
    blockchain.add_transaction("Bob", "Charlie", 25)

    mined_block = blockchain.mine_pending_transactions()
    print(f"Block mined: {mined_block}")

    blockchain.add_transaction("Charlie", "Dave", 10)
    blockchain.add_transaction("Dave", "Eve", 5)

    mined_block = blockchain.mine_pending_transactions()
    print(f"Block mined: {mined_block}")

    is_valid = blockchain.is_chain_valid()
    print(f"Is blockchain valid? {is_valid}")

    for block in blockchain.chain:
        print(block)